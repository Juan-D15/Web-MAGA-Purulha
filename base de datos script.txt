-- =====================================================
-- SCRIPT COMPLETO: SISTEMA DE GESTIÓN MAGA PURULHÁ
-- Incluye: Creación de BD + Zona Horaria + Colaboradores
-- Versión: 2.0 con tabla de colaboradores integrada
-- =====================================================

-- =====================================================
-- PASO 1: EXTENSIONES Y CONFIGURACIÓN INICIAL
-- =====================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Establecer la zona horaria para Guatemala
SET timezone TO 'America/Guatemala';

-- =====================================================
-- PASO 2: CATÁLOGOS BÁSICOS
-- =====================================================

-- TABLA: TIPOS DE COMUNIDAD
CREATE TABLE tipos_comunidad (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(50) NOT NULL CHECK (nombre IN ('barrio', 'caserío', 'aldea', 'municipio')),
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO tipos_comunidad (codigo, nombre) VALUES 
    ('BAR', 'barrio'),
    ('CAS', 'caserío'),
    ('ALD', 'aldea'),
    ('MUN', 'municipio');

-- TABLA: TIPOS DE BENEFICIARIO
CREATE TABLE tipos_beneficiario (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(50) NOT NULL CHECK (nombre IN ('individual', 'familia', 'institución')),
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO tipos_beneficiario (codigo, nombre) VALUES 
    ('IND', 'individual'),
    ('FAM', 'familia'),
    ('INST', 'institución');

-- TABLA: TIPOS DE ACTIVIDAD
CREATE TABLE tipos_actividad (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nombre VARCHAR(100) UNIQUE NOT NULL,
    descripcion TEXT,
    activo BOOLEAN DEFAULT TRUE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO tipos_actividad (nombre, descripcion) VALUES 
    ('Capacitación', 'Eventos de capacitación y formación'),
    ('Entrega', 'Entregas de insumos, materiales o recursos'),
    ('Proyecto de Ayuda', 'Proyectos de asistencia y desarrollo comunitario');

CREATE INDEX idx_tipos_actividad_activo ON tipos_actividad(activo);

-- TABLA: PUESTOS
CREATE TABLE puestos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT,
    activo BOOLEAN DEFAULT TRUE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_puestos_activo ON puestos(activo);
CREATE INDEX idx_puestos_codigo ON puestos(codigo);

COMMENT ON TABLE puestos IS 'Catálogo de puestos para personal de la organización';

-- =====================================================
-- PASO 3: ESTRUCTURA GEOGRÁFICA
-- =====================================================

-- TABLA: REGIONES
CREATE TABLE regiones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT,
    comunidad_sede VARCHAR(100),
    poblacion_aprox INT,
    latitud DECIMAL(10, 8),
    longitud DECIMAL(11, 8),
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_regiones_codigo ON regiones(codigo);

-- TABLA: COMUNIDADES
CREATE TABLE comunidades (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    codigo VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    tipo_id UUID REFERENCES tipos_comunidad(id) ON DELETE RESTRICT,
    region_id UUID REFERENCES regiones(id) ON DELETE SET NULL,
    descripcion TEXT,
    poblacion INT,
    latitud DECIMAL(10, 8),
    longitud DECIMAL(11, 8),
    cocode VARCHAR(100),
    telefono_cocode VARCHAR(20),
    activo BOOLEAN DEFAULT TRUE,
    version INTEGER DEFAULT 1,
    ultimo_sync TIMESTAMPTZ,
    modificado_offline BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_comunidades_codigo ON comunidades(codigo);
CREATE INDEX idx_comunidades_tipo ON comunidades(tipo_id);
CREATE INDEX idx_comunidades_region ON comunidades(region_id);
CREATE INDEX idx_comunidades_activo ON comunidades(activo);
CREATE INDEX idx_comunidades_sync ON comunidades(ultimo_sync, actualizado_en) WHERE modificado_offline = TRUE;

-- TABLA: AUTORIDADES DE COMUNIDAD
CREATE TABLE comunidad_autoridades (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    comunidad_id UUID REFERENCES comunidades(id) ON DELETE CASCADE,
    rol VARCHAR(50) NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    activo BOOLEAN DEFAULT TRUE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_autoridades_comunidad ON comunidad_autoridades(comunidad_id);

-- =====================================================
-- PASO 4: USUARIOS Y SEGURIDAD
-- =====================================================

-- TABLA: USUARIOS
CREATE TABLE usuarios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(150),
    email VARCHAR(100) UNIQUE NOT NULL,
    telefono VARCHAR(20),
    password_hash TEXT NOT NULL,
    rol VARCHAR(50) NOT NULL CHECK (rol IN ('admin', 'personal')),
    puesto_id UUID REFERENCES puestos(id) ON DELETE SET NULL,
    activo BOOLEAN DEFAULT TRUE,
    intentos_fallidos INT DEFAULT 0,
    bloqueado_hasta TIMESTAMPTZ,
    ultimo_login TIMESTAMPTZ,
    ultimo_logout TIMESTAMPTZ,
    token_refresh TEXT,
    token_expiracion TIMESTAMPTZ,
    permite_offline BOOLEAN DEFAULT TRUE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT check_personal_puesto CHECK (
        (rol = 'admin' AND puesto_id IS NULL) OR 
        (rol = 'personal' AND puesto_id IS NOT NULL)
    )
);

CREATE INDEX idx_usuarios_username ON usuarios(username);
CREATE INDEX idx_usuarios_email ON usuarios(email);
CREATE INDEX idx_usuarios_activo ON usuarios(activo);
CREATE INDEX idx_usuarios_rol ON usuarios(rol);
CREATE INDEX idx_usuarios_puesto ON usuarios(puesto_id);
CREATE INDEX idx_usuarios_nombre ON usuarios(nombre);

COMMENT ON TABLE usuarios IS 'Almacena información de usuarios del sistema con control de acceso';
COMMENT ON COLUMN usuarios.puesto_id IS 'Puesto que ocupa el usuario (solo para rol personal)';

-- =====================================================
-- PASO 5: COLABORADORES (NUEVA TABLA)
-- =====================================================

-- TABLA: COLABORADORES
CREATE TABLE colaboradores (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Información personal
    nombre VARCHAR(150) NOT NULL,
    puesto_id UUID REFERENCES puestos(id) ON DELETE SET NULL,
    descripcion TEXT,
    telefono VARCHAR(20),
    correo VARCHAR(100),
    dpi VARCHAR(20),
    
    -- Tipo de colaborador
    es_personal_fijo BOOLEAN DEFAULT FALSE,
    
    -- Relación con usuario del sistema (solo para personal fijo)
    usuario_id UUID UNIQUE REFERENCES usuarios(id) ON DELETE SET NULL,
    
    -- Estado
    activo BOOLEAN DEFAULT TRUE,
    
    -- Auditoría
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    
    -- Constraints
    CONSTRAINT check_personal_fijo_usuario CHECK (
        (es_personal_fijo = FALSE AND usuario_id IS NULL) OR 
        (es_personal_fijo = TRUE AND usuario_id IS NOT NULL)
    )
);

CREATE INDEX idx_colaboradores_puesto ON colaboradores(puesto_id);
CREATE INDEX idx_colaboradores_activo ON colaboradores(activo);
CREATE INDEX idx_colaboradores_usuario ON colaboradores(usuario_id);
CREATE INDEX idx_colaboradores_nombre ON colaboradores(nombre);
CREATE INDEX idx_colaboradores_es_personal_fijo ON colaboradores(es_personal_fijo);
CREATE INDEX idx_colaboradores_correo ON colaboradores(correo);

COMMENT ON TABLE colaboradores IS 'Registro de todos los colaboradores: personal fijo de oficina y colaboradores externos';
COMMENT ON COLUMN colaboradores.es_personal_fijo IS 'Indica si el colaborador trabaja permanentemente en oficina y requiere usuario del sistema';
COMMENT ON COLUMN colaboradores.usuario_id IS 'Usuario del sistema (solo para personal fijo de oficina)';
COMMENT ON COLUMN colaboradores.dpi IS 'Documento Personal de Identificación (opcional)';

-- =====================================================
-- PASO 6: DISPOSITIVOS Y SESIONES
-- =====================================================

-- TABLA: DISPOSITIVOS REGISTRADOS
CREATE TABLE dispositivos_registrados (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
    dispositivo_id VARCHAR(100) UNIQUE NOT NULL,
    nombre_dispositivo VARCHAR(200),
    navegador VARCHAR(100),
    sistema_operativo VARCHAR(100),
    ultimo_acceso TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    ultimo_sync TIMESTAMPTZ,
    activo BOOLEAN DEFAULT TRUE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_dispositivos_usuario ON dispositivos_registrados(usuario_id);
CREATE INDEX idx_dispositivos_activo ON dispositivos_registrados(activo);

-- TABLA: SESIONES OFFLINE
CREATE TABLE sesiones_offline (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
    dispositivo_id VARCHAR(100) NOT NULL,
    token_hash TEXT NOT NULL,
    refresh_token_hash TEXT,
    permisos_offline JSONB,
    datos_cache JSONB,
    sesion_activa BOOLEAN DEFAULT TRUE,
    iniciada_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    expira_en TIMESTAMPTZ NOT NULL,
    ultima_actividad TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    ultima_sincronizacion TIMESTAMPTZ,
    requiere_reautenticacion BOOLEAN DEFAULT FALSE,
    navegador VARCHAR(100),
    sistema_operativo VARCHAR(100),
    ip_address VARCHAR(50),
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sesiones_usuario_dispositivo ON sesiones_offline(usuario_id, dispositivo_id);
CREATE INDEX idx_sesiones_token ON sesiones_offline(token_hash);
CREATE INDEX idx_sesiones_activa ON sesiones_offline(sesion_activa) WHERE sesion_activa = TRUE;
CREATE INDEX idx_sesiones_expiracion ON sesiones_offline(expira_en);

-- =====================================================
-- PASO 7: BENEFICIARIOS
-- =====================================================

-- TABLA: BENEFICIARIOS (PRINCIPAL)
CREATE TABLE beneficiarios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tipo_id UUID NOT NULL REFERENCES tipos_beneficiario(id) ON DELETE RESTRICT,
    comunidad_id UUID REFERENCES comunidades(id) ON DELETE SET NULL,
    activo BOOLEAN DEFAULT TRUE,
    version INTEGER DEFAULT 1,
    ultimo_sync TIMESTAMPTZ,
    modificado_offline BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_beneficiarios_tipo ON beneficiarios(tipo_id);
CREATE INDEX idx_beneficiarios_comunidad ON beneficiarios(comunidad_id);
CREATE INDEX idx_beneficiarios_activo ON beneficiarios(activo);
CREATE INDEX idx_beneficiarios_sync ON beneficiarios(ultimo_sync, actualizado_en) WHERE modificado_offline = TRUE;

COMMENT ON TABLE beneficiarios IS 'Tabla principal de beneficiarios (polimórfica) - la dirección es comunidad_id';

-- TABLA: BENEFICIARIOS INDIVIDUALES
CREATE TABLE beneficiarios_individuales (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    beneficiario_id UUID UNIQUE NOT NULL REFERENCES beneficiarios(id) ON DELETE CASCADE,
    nombre VARCHAR(150) NOT NULL,
    apellido VARCHAR(150) NOT NULL,
    dpi VARCHAR(20) UNIQUE,
    fecha_nacimiento DATE,
    genero VARCHAR(20) CHECK (genero IN ('masculino', 'femenino', 'otro')),
    telefono VARCHAR(20),
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_beneficiarios_ind_beneficiario ON beneficiarios_individuales(beneficiario_id);
CREATE INDEX idx_beneficiarios_ind_dpi ON beneficiarios_individuales(dpi);
CREATE INDEX idx_beneficiarios_ind_nombre ON beneficiarios_individuales(nombre, apellido);

COMMENT ON TABLE beneficiarios_individuales IS 'Datos específicos de beneficiarios individuales';

-- TABLA: BENEFICIARIOS FAMILIAS
CREATE TABLE beneficiarios_familias (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    beneficiario_id UUID UNIQUE NOT NULL REFERENCES beneficiarios(id) ON DELETE CASCADE,
    nombre_familia VARCHAR(150) NOT NULL,
    jefe_familia VARCHAR(150) NOT NULL,
    dpi_jefe_familia VARCHAR(20) UNIQUE,
    telefono VARCHAR(20),
    numero_miembros INT,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_beneficiarios_fam_beneficiario ON beneficiarios_familias(beneficiario_id);
CREATE INDEX idx_beneficiarios_fam_dpi ON beneficiarios_familias(dpi_jefe_familia);
CREATE INDEX idx_beneficiarios_fam_nombre ON beneficiarios_familias(nombre_familia);

COMMENT ON TABLE beneficiarios_familias IS 'Datos específicos de familias beneficiarias';

-- TABLA: BENEFICIARIOS INSTITUCIONES
CREATE TABLE beneficiarios_instituciones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    beneficiario_id UUID UNIQUE NOT NULL REFERENCES beneficiarios(id) ON DELETE CASCADE,
    nombre_institucion VARCHAR(200) NOT NULL,
    tipo_institucion VARCHAR(50) NOT NULL CHECK (tipo_institucion IN ('escuela', 'cooperativa', 'asociación', 'ONG', 'iglesia', 'otro')),
    representante_legal VARCHAR(150),
    dpi_representante VARCHAR(20),
    telefono VARCHAR(20),
    email VARCHAR(100),
    numero_beneficiarios_directos INT,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_beneficiarios_inst_beneficiario ON beneficiarios_instituciones(beneficiario_id);
CREATE INDEX idx_beneficiarios_inst_tipo ON beneficiarios_instituciones(tipo_institucion);
CREATE INDEX idx_beneficiarios_inst_nombre ON beneficiarios_instituciones(nombre_institucion);

COMMENT ON TABLE beneficiarios_instituciones IS 'Datos específicos de instituciones beneficiarias (escuelas, cooperativas, etc)';

-- =====================================================
-- PASO 8: ACTIVIDADES
-- =====================================================

-- TABLA: ACTIVIDADES
CREATE TABLE actividades (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tipo_id UUID REFERENCES tipos_actividad(id) ON DELETE RESTRICT,
    comunidad_id UUID REFERENCES comunidades(id) ON DELETE SET NULL,
    responsable_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    colaborador_id UUID REFERENCES colaboradores(id) ON DELETE SET NULL,
    nombre VARCHAR(200) NOT NULL,
    fecha DATE NOT NULL,
    descripcion TEXT,
    estado VARCHAR(50) DEFAULT 'planificado' CHECK (estado IN ('planificado', 'en_progreso', 'completado', 'cancelado')),
    latitud DECIMAL(10, 8),
    longitud DECIMAL(11, 8),
    version INTEGER DEFAULT 1,
    ultimo_sync TIMESTAMPTZ,
    modificado_offline BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    eliminado_en TIMESTAMPTZ
);

CREATE INDEX idx_actividades_tipo ON actividades(tipo_id);
CREATE INDEX idx_actividades_comunidad ON actividades(comunidad_id);
CREATE INDEX idx_actividades_responsable ON actividades(responsable_id);
CREATE INDEX idx_actividades_colaborador ON actividades(colaborador_id);
CREATE INDEX idx_actividades_fecha ON actividades(fecha);
CREATE INDEX idx_actividades_estado ON actividades(estado);
CREATE INDEX idx_actividades_eliminado ON actividades(eliminado_en);
CREATE INDEX idx_actividades_sync ON actividades(ultimo_sync, actualizado_en) WHERE modificado_offline = TRUE;

COMMENT ON TABLE actividades IS 'Registro de capacitaciones, entregas y proyectos';
COMMENT ON COLUMN actividades.colaborador_id IS 'Colaborador asignado a la actividad (puede ser personal fijo o externo)';

-- TABLA: PERSONAL DE ACTIVIDADES
CREATE TABLE actividad_personal (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    actividad_id UUID REFERENCES actividades(id) ON DELETE CASCADE,
    usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
    colaborador_id UUID REFERENCES colaboradores(id) ON DELETE CASCADE,
    rol_en_actividad VARCHAR(50) NOT NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_actividad_colaborador_usuario UNIQUE(actividad_id, colaborador_id, usuario_id),
    CONSTRAINT check_tiene_colaborador_o_usuario CHECK (
        (colaborador_id IS NOT NULL) OR (usuario_id IS NOT NULL)
    )
);

CREATE INDEX idx_actividad_personal_actividad ON actividad_personal(actividad_id);
CREATE INDEX idx_actividad_personal_usuario ON actividad_personal(usuario_id);
CREATE INDEX idx_actividad_personal_colaborador ON actividad_personal(colaborador_id);

COMMENT ON COLUMN actividad_personal.colaborador_id IS 'Colaborador asignado al personal de la actividad';

-- TABLA: BENEFICIARIOS POR ACTIVIDAD
CREATE TABLE actividad_beneficiarios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    actividad_id UUID REFERENCES actividades(id) ON DELETE CASCADE,
    beneficiario_id UUID REFERENCES beneficiarios(id) ON DELETE CASCADE,
    version INTEGER DEFAULT 1,
    sincronizado BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(actividad_id, beneficiario_id)
);

CREATE INDEX idx_actividad_beneficiarios_actividad ON actividad_beneficiarios(actividad_id);
CREATE INDEX idx_actividad_beneficiarios_beneficiario ON actividad_beneficiarios(beneficiario_id);

-- TABLA: EVIDENCIAS
CREATE TABLE evidencias (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    actividad_id UUID REFERENCES actividades(id) ON DELETE CASCADE,
    archivo_nombre VARCHAR(255) NOT NULL,
    archivo_tipo VARCHAR(50),
    archivo_tamanio BIGINT,
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    es_imagen BOOLEAN DEFAULT TRUE,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    version INTEGER DEFAULT 1,
    ultimo_sync TIMESTAMPTZ,
    sincronizado BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_evidencias_actividad ON evidencias(actividad_id);
CREATE INDEX idx_evidencias_creado_por ON evidencias(creado_por);
CREATE INDEX idx_evidencias_sync ON evidencias(sincronizado, creado_en) WHERE sincronizado = FALSE;

COMMENT ON TABLE evidencias IS 'Archivos multimedia de evidencia de actividades';

-- TABLA: CAMBIOS/ACTUALIZACIONES DE ACTIVIDADES
CREATE TABLE actividad_cambios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    actividad_id UUID REFERENCES actividades(id) ON DELETE CASCADE,
    responsable_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    colaborador_id UUID REFERENCES colaboradores(id) ON DELETE SET NULL,
    descripcion_cambio TEXT NOT NULL,
    fecha_cambio TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_cambios_actividad ON actividad_cambios(actividad_id);
CREATE INDEX idx_cambios_fecha ON actividad_cambios(fecha_cambio);
CREATE INDEX idx_actividad_cambios_actividad_id ON actividad_cambios(actividad_id);
CREATE INDEX idx_actividad_cambios_responsable_id ON actividad_cambios(responsable_id);
CREATE INDEX idx_actividad_cambios_colaborador ON actividad_cambios(colaborador_id);
CREATE INDEX idx_actividad_cambios_fecha_cambio ON actividad_cambios(fecha_cambio DESC);

COMMENT ON COLUMN actividad_cambios.colaborador_id IS 'Colaborador que registró el cambio';

-- TABLA: EVIDENCIAS DE CAMBIOS
CREATE TABLE cambio_evidencias (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cambio_id UUID REFERENCES actividad_cambios(id) ON DELETE CASCADE,
    archivo_nombre VARCHAR(255) NOT NULL,
    archivo_tipo VARCHAR(50),
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_cambio_evidencias_cambio ON cambio_evidencias(cambio_id);

-- TABLA: ARCHIVOS DE PROYECTOS/ACTIVIDADES
CREATE TABLE actividad_archivos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    actividad_id UUID REFERENCES actividades(id) ON DELETE CASCADE,
    nombre_archivo VARCHAR(255) NOT NULL,
    archivo_tipo VARCHAR(50),
    archivo_tamanio BIGINT,
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_actividad_archivos_actividad ON actividad_archivos(actividad_id);

-- =====================================================
-- PASO 9: ARCHIVOS Y GALERÍAS
-- =====================================================

-- TABLA: GALERÍA DE COMUNIDADES
CREATE TABLE comunidad_galeria (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    comunidad_id UUID REFERENCES comunidades(id) ON DELETE CASCADE,
    archivo_nombre VARCHAR(255) NOT NULL,
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_comunidad_galeria_comunidad ON comunidad_galeria(comunidad_id);

-- TABLA: ARCHIVOS DE COMUNIDADES
CREATE TABLE comunidad_archivos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    comunidad_id UUID REFERENCES comunidades(id) ON DELETE CASCADE,
    nombre_archivo VARCHAR(255) NOT NULL,
    archivo_tipo VARCHAR(50),
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_comunidad_archivos_comunidad ON comunidad_archivos(comunidad_id);

-- TABLA: GALERÍA DE REGIONES
CREATE TABLE region_galeria (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    region_id UUID REFERENCES regiones(id) ON DELETE CASCADE,
    archivo_nombre VARCHAR(255) NOT NULL,
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_region_galeria_region ON region_galeria(region_id);

-- TABLA: ARCHIVOS DE REGIONES
CREATE TABLE region_archivos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    region_id UUID REFERENCES regiones(id) ON DELETE CASCADE,
    nombre_archivo VARCHAR(255) NOT NULL,
    archivo_tipo VARCHAR(50),
    url_almacenamiento TEXT NOT NULL,
    descripcion TEXT,
    creado_por UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_region_archivos_region ON region_archivos(region_id);

-- =====================================================
-- PASO 10: TARJETAS Y AUDITORÍA
-- =====================================================

-- TABLA: TARJETAS PERSONALIZADAS
CREATE TABLE tarjetas_datos (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    entidad_tipo VARCHAR(20) NOT NULL CHECK (entidad_tipo IN ('actividad', 'comunidad', 'region')),
    entidad_id UUID NOT NULL,
    titulo VARCHAR(100) NOT NULL,
    valor TEXT,
    icono VARCHAR(50),
    orden INT DEFAULT 0,
    es_favorita BOOLEAN DEFAULT FALSE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_tarjetas_entidad ON tarjetas_datos(entidad_tipo, entidad_id);
CREATE INDEX idx_tarjetas_favorita ON tarjetas_datos(es_favorita);

-- TABLA: BITÁCORA DE TRANSACCIONES
CREATE TABLE bitacora_transacciones (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    usuario_id UUID REFERENCES usuarios(id) ON DELETE SET NULL,
    accion VARCHAR(50) NOT NULL,
    tabla_afectada VARCHAR(100) NOT NULL,
    registro_id UUID,
    datos_anteriores JSONB,
    datos_nuevos JSONB,
    ip_address VARCHAR(50),
    user_agent TEXT,
    resultado VARCHAR(20) CHECK (resultado IN ('exitoso', 'fallido')),
    mensaje_error TEXT,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_bitacora_usuario ON bitacora_transacciones(usuario_id);
CREATE INDEX idx_bitacora_tabla ON bitacora_transacciones(tabla_afectada);
CREATE INDEX idx_bitacora_fecha ON bitacora_transacciones(creado_en);
CREATE INDEX idx_bitacora_accion ON bitacora_transacciones(accion);

COMMENT ON TABLE bitacora_transacciones IS 'Auditoría completa de operaciones del sistema';

-- =====================================================
-- PASO 11: SINCRONIZACIÓN OFFLINE
-- =====================================================

-- TABLA: COLA DE SINCRONIZACIÓN
CREATE TABLE cola_sincronizacion (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    usuario_id UUID REFERENCES usuarios(id) ON DELETE CASCADE,
    dispositivo_id VARCHAR(100),
    operacion VARCHAR(20) NOT NULL CHECK (operacion IN ('INSERT', 'UPDATE', 'DELETE')),
    tabla VARCHAR(100) NOT NULL,
    registro_id UUID NOT NULL,
    datos JSONB NOT NULL,
    datos_anteriores JSONB,
    version_local INTEGER DEFAULT 1,
    version_servidor INTEGER,
    sincronizado BOOLEAN DEFAULT FALSE,
    sincronizado_en TIMESTAMPTZ,
    intentos INT DEFAULT 0,
    max_intentos INT DEFAULT 5,
    ultimo_intento TIMESTAMPTZ,
    tiene_conflicto BOOLEAN DEFAULT FALSE,
    conflicto_resuelto BOOLEAN DEFAULT FALSE,
    error_mensaje TEXT,
    hash_datos VARCHAR(64),
    prioridad INT DEFAULT 0,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    procesado_en TIMESTAMPTZ,
    CONSTRAINT unique_operacion_por_registro UNIQUE (tabla, registro_id, operacion, hash_datos)
);

CREATE INDEX idx_cola_sincronizado_pendiente ON cola_sincronizacion(sincronizado, creado_en) WHERE sincronizado = FALSE;
CREATE INDEX idx_cola_usuario_dispositivo ON cola_sincronizacion(usuario_id, dispositivo_id);
CREATE INDEX idx_cola_tabla_registro ON cola_sincronizacion(tabla, registro_id);
CREATE INDEX idx_cola_tiene_conflicto ON cola_sincronizacion(tiene_conflicto) WHERE tiene_conflicto = TRUE;
CREATE INDEX idx_cola_prioridad ON cola_sincronizacion(prioridad DESC, creado_en);

COMMENT ON TABLE cola_sincronizacion IS 'Cola para sincronización de datos en modo offline';

-- TABLA: CONFLICTOS DE SINCRONIZACIÓN
CREATE TABLE conflictos_sincronizacion (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    cola_sincronizacion_id UUID REFERENCES cola_sincronizacion(id) ON DELETE CASCADE,
    tabla VARCHAR(100) NOT NULL,
    registro_id UUID NOT NULL,
    campo_conflicto VARCHAR(100),
    valor_local JSONB,
    valor_servidor JSONB,
    version_local INTEGER,
    version_servidor INTEGER,
    resuelto BOOLEAN DEFAULT FALSE,
    estrategia_resolucion VARCHAR(50) CHECK (estrategia_resolucion IN ('usar_servidor', 'usar_local', 'merge', 'manual')),
    valor_final JSONB,
    resuelto_por UUID REFERENCES usuarios(id),
    resuelto_en TIMESTAMPTZ,
    detectado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    notas TEXT
);

CREATE INDEX idx_conflictos_resuelto ON conflictos_sincronizacion(resuelto);
CREATE INDEX idx_conflictos_tabla_registro ON conflictos_sincronizacion(tabla, registro_id);

-- =====================================================
-- PASO 12: FUNCIONES Y TRIGGERS
-- =====================================================

-- Función para actualizar timestamp automáticamente
CREATE OR REPLACE FUNCTION actualizar_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.actualizado_en = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Función para incrementar versión automáticamente
CREATE OR REPLACE FUNCTION incrementar_version()
RETURNS TRIGGER AS $$
BEGIN
    NEW.version = COALESCE(OLD.version, 0) + 1;
    NEW.actualizado_en = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Función para registrar cambios en cola
CREATE OR REPLACE FUNCTION registrar_en_cola_sincronizacion()
RETURNS TRIGGER AS $$
DECLARE
    operacion_tipo VARCHAR(20);
    datos_registro JSONB;
BEGIN
    IF (TG_OP ='INSERT') THEN
        operacion_tipo = 'INSERT';
        datos_registro = row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'UPDATE') THEN
        operacion_tipo = 'UPDATE';
        datos_registro = row_to_json(NEW)::jsonb;
    ELSIF (TG_OP = 'DELETE') THEN
        operacion_tipo = 'DELETE';
        datos_registro = row_to_json(OLD)::jsonb;
    END IF;
    
    IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.modificado_offline = TRUE)) THEN
        INSERT INTO cola_sincronizacion (
            tabla,
            registro_id,
            operacion,
            datos,
            hash_datos
        ) VALUES (
            TG_TABLE_NAME,
            COALESCE(NEW.id, OLD.id),
            operacion_tipo,
            datos_registro,
            MD5(datos_registro::text)
        )
        ON CONFLICT (tabla, registro_id, operacion, hash_datos) 
        DO NOTHING;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Función para obtener cambios desde una fecha
CREATE OR REPLACE FUNCTION obtener_cambios_desde(
    p_tabla VARCHAR,
    p_ultimo_sync TIMESTAMP,
    p_usuario_id UUID DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    datos JSONB,
    version INTEGER,
    actualizado_en TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY EXECUTE format(
        'SELECT id, row_to_json(%I)::jsonb as datos, version, actualizado_en 
         FROM %I 
         WHERE actualizado_en > $1
         AND (eliminado_en IS NULL OR eliminado_en > $1)
         ORDER BY actualizado_en',
        p_tabla, p_tabla
    ) USING p_ultimo_sync;
END;
$$ LANGUAGE plpgsql;

-- Función para procesar cola de sincronización
CREATE OR REPLACE FUNCTION procesar_cola_sincronizacion(
    p_cola_id UUID,
    p_exito BOOLEAN,
    p_version_servidor INTEGER DEFAULT NULL,
    p_mensaje_error TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE cola_sincronizacion
    SET 
        sincronizado = p_exito,
        sincronizado_en = CASE WHEN p_exito THEN CURRENT_TIMESTAMP ELSE NULL END,
        version_servidor = p_version_servidor,
        intentos = intentos + 1,
        ultimo_intento = CURRENT_TIMESTAMP,
        error_mensaje = p_mensaje_error,
        procesado_en = CASE WHEN p_exito THEN CURRENT_TIMESTAMP ELSE procesado_en END
    WHERE id = p_cola_id;
    
    IF p_exito THEN
        EXECUTE format(
            'UPDATE %I SET ultimo_sync = CURRENT_TIMESTAMP, modificado_offline = FALSE 
             WHERE id = $1',
            (SELECT tabla FROM cola_sincronizacion WHERE id = p_cola_id)
        ) USING (SELECT registro_id FROM cola_sincronizacion WHERE id = p_cola_id);
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Función para sincronizar usuario con colaborador
CREATE OR REPLACE FUNCTION sincronizar_colaborador_usuario()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.usuario_id IS NOT NULL AND OLD.usuario_id IS NULL THEN
        NEW.es_personal_fijo = TRUE;
    END IF;
    
    IF NEW.usuario_id IS NULL AND OLD.usuario_id IS NOT NULL THEN
        NEW.es_personal_fijo = FALSE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Función para crear colaborador con usuario
CREATE OR REPLACE FUNCTION crear_colaborador_con_usuario(
    p_nombre VARCHAR(150),
    p_puesto_id UUID,
    p_telefono VARCHAR(20),
    p_correo VARCHAR(100),
    p_descripcion TEXT DEFAULT NULL,
    p_dpi VARCHAR(20) DEFAULT NULL,
    p_username VARCHAR(50) DEFAULT NULL,
    p_password_hash TEXT DEFAULT NULL,
    p_creado_por UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_colaborador_id UUID;
    v_usuario_id UUID;
BEGIN
    INSERT INTO colaboradores (
        nombre, puesto_id, descripcion, telefono, correo, dpi, 
        es_personal_fijo, activo, creado_por
    ) VALUES (
        p_nombre, p_puesto_id, p_descripcion, p_telefono, p_correo, p_dpi,
        TRUE, TRUE, p_creado_por
    ) RETURNING id INTO v_colaborador_id;
    
    IF p_username IS NOT NULL AND p_password_hash IS NOT NULL THEN
        INSERT INTO usuarios (
            username, nombre, email, telefono, password_hash, 
            rol, puesto_id, activo
        ) VALUES (
            p_username, p_nombre, p_correo, p_telefono, p_password_hash,
            'personal', p_puesto_id, TRUE
        ) RETURNING id INTO v_usuario_id;
        
        UPDATE colaboradores 
        SET usuario_id = v_usuario_id 
        WHERE id = v_colaborador_id;
    END IF;
    
    RETURN v_colaborador_id;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- PASO 13: APLICAR TRIGGERS
-- =====================================================

-- Triggers para actualizar timestamp
CREATE TRIGGER trg_usuarios_timestamp BEFORE UPDATE ON usuarios
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_puestos_timestamp BEFORE UPDATE ON puestos
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_regiones_timestamp BEFORE UPDATE ON regiones
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_comunidades_timestamp BEFORE UPDATE ON comunidades
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_comunidad_autoridades_timestamp BEFORE UPDATE ON comunidad_autoridades
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_tipos_actividad_timestamp BEFORE UPDATE ON tipos_actividad
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_beneficiarios_timestamp BEFORE UPDATE ON beneficiarios
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_beneficiarios_ind_timestamp BEFORE UPDATE ON beneficiarios_individuales
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_beneficiarios_fam_timestamp BEFORE UPDATE ON beneficiarios_familias
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_beneficiarios_inst_timestamp BEFORE UPDATE ON beneficiarios_instituciones
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_actividades_timestamp BEFORE UPDATE ON actividades
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_tarjetas_timestamp BEFORE UPDATE ON tarjetas_datos
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

CREATE TRIGGER trg_colaboradores_timestamp BEFORE UPDATE ON colaboradores
    FOR EACH ROW EXECUTE FUNCTION actualizar_timestamp();

-- Triggers para incrementar versión
CREATE TRIGGER trg_actividades_version BEFORE UPDATE ON actividades
    FOR EACH ROW EXECUTE FUNCTION incrementar_version();

CREATE TRIGGER trg_beneficiarios_version BEFORE UPDATE ON beneficiarios
    FOR EACH ROW EXECUTE FUNCTION incrementar_version();

CREATE TRIGGER trg_comunidades_version BEFORE UPDATE ON comunidades
    FOR EACH ROW EXECUTE FUNCTION incrementar_version();

-- Trigger para sincronizar colaborador con usuario
CREATE TRIGGER trg_colaborador_usuario_sync 
BEFORE UPDATE ON colaboradores
FOR EACH ROW 
EXECUTE FUNCTION sincronizar_colaborador_usuario();

-- =====================================================
-- PASO 14: VISTAS - CONSULTAS BÁSICAS
-- =====================================================

-- Vista: Usuarios Completos
CREATE VIEW vista_usuarios_completos AS
SELECT 
    u.id,
    u.username,
    u.nombre,
    u.email,
    u.telefono,
    u.rol,
    p.nombre as puesto,
    p.codigo as puesto_codigo,
    u.activo,
    u.intentos_fallidos,
    u.bloqueado_hasta,
    u.creado_en,
    u.actualizado_en
FROM usuarios u
LEFT JOIN puestos p ON u.puesto_id = p.id;

-- Vista: Colaboradores Completos
CREATE VIEW vista_colaboradores_completos AS
SELECT 
    c.id,
    c.nombre,
    c.descripcion,
    c.telefono,
    c.correo,
    c.dpi,
    c.es_personal_fijo,
    c.activo,
    p.nombre as puesto,
    p.codigo as puesto_codigo,
    p.descripcion as puesto_descripcion,
    u.id as usuario_id,
    u.username,
    u.email as usuario_email,
    u.rol as usuario_rol,
    u.activo as usuario_activo,
    COUNT(DISTINCT a.id) as total_actividades_asignadas,
    COUNT(DISTINCT CASE WHEN a.estado = 'completado' THEN a.id END) as actividades_completadas,
    COUNT(DISTINCT CASE WHEN a.estado = 'en_progreso' THEN a.id END) as actividades_en_progreso,
    COUNT(DISTINCT ap.actividad_id) as total_actividades_como_personal,
    COUNT(DISTINCT ac.id) as total_cambios_registrados,
    c.creado_en,
    c.actualizado_en,
    uc.username as creado_por_username
FROM colaboradores c
LEFT JOIN puestos p ON c.puesto_id = p.id
LEFT JOIN usuarios u ON c.usuario_id = u.id
LEFT JOIN actividades a ON c.id = a.colaborador_id
LEFT JOIN actividad_personal ap ON c.id = ap.colaborador_id
LEFT JOIN actividad_cambios ac ON c.id = ac.colaborador_id
LEFT JOIN usuarios uc ON c.creado_por = uc.id
GROUP BY c.id, p.nombre, p.codigo, p.descripcion, u.id, u.username, u.email, u.rol, u.activo, uc.username;

-- Vista: Colaboradores Disponibles
CREATE VIEW vista_colaboradores_disponibles AS
SELECT 
    c.id,
    c.nombre,
    c.telefono,
    c.correo,
    p.nombre as puesto,
    c.es_personal_fijo,
    c.descripcion,
    CASE 
        WHEN c.es_personal_fijo THEN 'Personal Fijo'
        ELSE 'Colaborador Externo'
    END as tipo_colaborador,
    COUNT(DISTINCT CASE 
        WHEN a.estado IN ('planificado', 'en_progreso') 
        THEN a.id 
    END) as actividades_activas,
    MAX(a.fecha) as ultima_actividad_asignada
FROM colaboradores c
LEFT JOIN puestos p ON c.puesto_id = p.id
LEFT JOIN actividades a ON c.id = a.colaborador_id
WHERE c.activo = TRUE
GROUP BY c.id, c.nombre, c.telefono, c.correo, p.nombre, c.es_personal_fijo, c.descripcion
ORDER BY c.nombre;

-- Vista: Actividades Completas
CREATE VIEW vista_actividades_completas AS
SELECT 
    a.id,
    a.nombre,
    a.fecha,
    a.descripcion,
    a.estado,
    ta.nombre as tipo_actividad,
    ta.id as tipo_actividad_id,
    c.nombre as comunidad,
    c.codigo as comunidad_codigo,
    c.id as comunidad_id,
    r.nombre as region,
    r.id as region_id,
    u.username as responsable,
    u.id as responsable_id,
    u.rol as rol_responsable,
    p.nombre as puesto_responsable,
    col.id as colaborador_id,
    col.nombre as colaborador_nombre,
    col.telefono as colaborador_telefono,
    col.correo as colaborador_correo,
    col.es_personal_fijo as colaborador_es_personal_fijo,
    pcol.nombre as colaborador_puesto,
    a.latitud,
    a.longitud,
    COUNT(DISTINCT ab.beneficiario_id) as total_beneficiarios,
    COUNT(DISTINCT e.id) as total_evidencias,
    COUNT(DISTINCT ac.id) as total_cambios,
    a.creado_en,
    a.actualizado_en
FROM actividades a
LEFT JOIN tipos_actividad ta ON a.tipo_id = ta.id
LEFT JOIN comunidades c ON a.comunidad_id = c.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN usuarios u ON a.responsable_id = u.id
LEFT JOIN puestos p ON u.puesto_id = p.id
LEFT JOIN colaboradores col ON a.colaborador_id = col.id
LEFT JOIN puestos pcol ON col.puesto_id = pcol.id
LEFT JOIN actividad_beneficiarios ab ON a.id = ab.actividad_id
LEFT JOIN evidencias e ON a.id = e.actividad_id
LEFT JOIN actividad_cambios ac ON a.id = ac.actividad_id
WHERE a.eliminado_en IS NULL
GROUP BY a.id, ta.nombre, ta.id, c.nombre, c.codigo, c.id, r.nombre, r.id, 
         u.username, u.id, u.rol, p.nombre,
         col.id, col.nombre, col.telefono, col.correo, col.es_personal_fijo, pcol.nombre;

-- Vista: Comunidades con Estadísticas
CREATE VIEW vista_comunidades_estadisticas AS
SELECT 
    c.id,
    c.codigo,
    c.nombre,
    tc.nombre as tipo,
    r.nombre as region,
    r.id as region_id,
    c.poblacion,
    COUNT(DISTINCT a.id) as total_actividades,
    COUNT(DISTINCT b.id) as total_beneficiarios,
    c.creado_en
FROM comunidades c
LEFT JOIN tipos_comunidad tc ON c.tipo_id = tc.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN actividades a ON c.id = a.comunidad_id AND a.eliminado_en IS NULL
LEFT JOIN beneficiarios b ON c.id = b.comunidad_id
WHERE c.activo = TRUE
GROUP BY c.id, tc.nombre, r.nombre, r.id;

-- =====================================================
-- PASO 15: VISTAS - REPORTES AVANZADOS
-- =====================================================

-- Vista: Reporte de Beneficiarios
CREATE VIEW reporte_beneficiarios AS
SELECT 
    b.id,
    tb.nombre as tipo_beneficiario,
    CASE 
        WHEN tb.nombre = 'individual' THEN CONCAT(bi.nombre, ' ', bi.apellido)
        WHEN tb.nombre = 'familia' THEN bf.nombre_familia
        WHEN tb.nombre = 'institución' THEN bin.nombre_institucion
    END as nombre_completo,
    CASE 
        WHEN tb.nombre = 'individual' THEN bi.dpi
        WHEN tb.nombre = 'familia' THEN bf.dpi_jefe_familia
        WHEN tb.nombre = 'institución' THEN bin.dpi_representante
    END as documento_identificacion,
    CASE 
        WHEN tb.nombre = 'individual' THEN bi.telefono
        WHEN tb.nombre = 'familia' THEN bf.telefono
        WHEN tb.nombre = 'institución' THEN bin.telefono
    END as telefono,
    bin.email,
    bi.genero,
    bi.fecha_nacimiento,
    bf.jefe_familia,
    bf.numero_miembros,
    bin.tipo_institucion,
    bin.representante_legal,
    bin.numero_beneficiarios_directos,
    c.nombre as comunidad,
    c.codigo as comunidad_codigo,
    tc.nombre as tipo_comunidad,
    r.nombre as region,
    COUNT(DISTINCT ab.actividad_id) as total_actividades_participadas,
    MIN(a.fecha) as primera_participacion,
    MAX(a.fecha) as ultima_participacion,
    STRING_AGG(DISTINCT ta.nombre, ', ') as tipos_actividades,
    b.activo,
    b.creado_en,
    b.actualizado_en
FROM beneficiarios b
INNER JOIN tipos_beneficiario tb ON b.tipo_id = tb.id
LEFT JOIN beneficiarios_individuales bi ON b.id = bi.beneficiario_id
LEFT JOIN beneficiarios_familias bf ON b.id = bf.beneficiario_id
LEFT JOIN beneficiarios_instituciones bin ON b.id = bin.beneficiario_id
LEFT JOIN comunidades c ON b.comunidad_id = c.id
LEFT JOIN tipos_comunidad tc ON c.tipo_id = tc.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN actividad_beneficiarios ab ON b.id = ab.beneficiario_id
LEFT JOIN actividades a ON ab.actividad_id = a.id AND a.eliminado_en IS NULL
LEFT JOIN tipos_actividad ta ON a.tipo_id = ta.id
GROUP BY b.id, tb.nombre, bi.nombre, bi.apellido, bi.dpi, bi.telefono, bi.genero, bi.fecha_nacimiento,
         bf.nombre_familia, bf.dpi_jefe_familia, bf.telefono, bf.jefe_familia, bf.numero_miembros,
         bin.nombre_institucion, bin.dpi_representante, bin.telefono, bin.email, bin.tipo_institucion, 
         bin.representante_legal, bin.numero_beneficiarios_directos,
         c.nombre, c.codigo, tc.nombre, r.nombre, b.activo, b.creado_en, b.actualizado_en;

-- Vista: Reporte de Eventos
CREATE VIEW reporte_eventos AS
SELECT 
    a.id,
    a.nombre,
    a.fecha,
    EXTRACT(YEAR FROM a.fecha) as anio,
    EXTRACT(MONTH FROM a.fecha) as mes,
    EXTRACT(QUARTER FROM a.fecha) as trimestre,
    a.estado,
    ta.nombre as tipo_actividad,
    c.nombre as comunidad,
    c.codigo as comunidad_codigo,
    tc.nombre as tipo_comunidad,
    r.nombre as region,
    u.username as responsable,
    u.rol as rol_responsable,
    p.nombre as puesto_responsable,
    col.nombre as colaborador,
    col.correo as colaborador_correo,
    col.telefono as colaborador_telefono,
    pcol.nombre as colaborador_puesto,
    col.es_personal_fijo as colaborador_es_personal_fijo,
    COUNT(DISTINCT ab.beneficiario_id) as total_beneficiarios,
    COUNT(DISTINCT ap.usuario_id) as total_personal_usuarios,
    COUNT(DISTINCT ap.colaborador_id) as total_personal_colaboradores,
    COUNT(DISTINCT e.id) as total_evidencias,
    COUNT(DISTINCT ac.id) as total_actualizaciones,
    a.descripcion,
    a.creado_en,
    a.actualizado_en
FROM actividades a
LEFT JOIN tipos_actividad ta ON a.tipo_id = ta.id
LEFT JOIN comunidades c ON a.comunidad_id = c.id
LEFT JOIN tipos_comunidad tc ON c.tipo_id = tc.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN usuarios u ON a.responsable_id = u.id
LEFT JOIN puestos p ON u.puesto_id = p.id
LEFT JOIN colaboradores col ON a.colaborador_id = col.id
LEFT JOIN puestos pcol ON col.puesto_id = pcol.id
LEFT JOIN actividad_beneficiarios ab ON a.id = ab.actividad_id
LEFT JOIN actividad_personal ap ON a.id = ap.actividad_id
LEFT JOIN evidencias e ON a.id = e.actividad_id
LEFT JOIN actividad_cambios ac ON a.id = ac.actividad_id
WHERE a.eliminado_en IS NULL
GROUP BY a.id, ta.nombre, c.nombre, c.codigo, tc.nombre, r.nombre, 
         u.username, u.rol, p.nombre,
         col.nombre, col.correo, col.telefono, pcol.nombre, col.es_personal_fijo;

-- Vista: Reporte de Avances de Eventos
CREATE VIEW reporte_avances_eventos AS
SELECT 
    a.id as actividad_id,
    a.nombre as actividad,
    a.fecha as fecha_actividad,
    a.estado,
    ta.nombre as tipo_actividad,
    c.nombre as comunidad,
    r.nombre as region,
    u.username as responsable,
    u.rol as rol_responsable,
    p.nombre as puesto_responsable,
    col.nombre as colaborador,
    col.correo as colaborador_correo,
    pcol.nombre as colaborador_puesto,
    COUNT(DISTINCT ab.beneficiario_id) as beneficiarios_registrados,
    COUNT(DISTINCT e.id) as evidencias_subidas,
    COUNT(DISTINCT aa.id) as archivos_adjuntos,
    COUNT(DISTINCT ac.id) as total_cambios,
    MAX(ac.fecha_cambio) as ultima_actualizacion,
    uc.ultimos_cambios,
    COUNT(DISTINCT ap.usuario_id) as total_personal_usuarios,
    COUNT(DISTINCT ap.colaborador_id) as total_personal_colaboradores,
    STRING_AGG(DISTINCT u2.username, ', ' ORDER BY u2.username) as usuarios_asignados,
    STRING_AGG(DISTINCT col2.nombre, ', ' ORDER BY col2.nombre) as colaboradores_asignados,
    CASE 
        WHEN a.estado = 'completado' THEN 100
        WHEN a.estado = 'en_progreso' THEN 50
        WHEN a.estado = 'planificado' THEN 0
        ELSE 0
    END as porcentaje_completado,
    CASE WHEN COUNT(DISTINCT e.id) > 0 THEN TRUE ELSE FALSE END as tiene_evidencias,
    a.creado_en as fecha_creacion,
    a.actualizado_en as fecha_ultima_modificacion
FROM actividades a
LEFT JOIN tipos_actividad ta ON a.tipo_id = ta.id
LEFT JOIN comunidades c ON a.comunidad_id = c.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN usuarios u ON a.responsable_id = u.id
LEFT JOIN puestos p ON u.puesto_id = p.id
LEFT JOIN colaboradores col ON a.colaborador_id = col.id
LEFT JOIN puestos pcol ON col.puesto_id = pcol.id
LEFT JOIN actividad_beneficiarios ab ON a.id = ab.actividad_id
LEFT JOIN evidencias e ON a.id = e.actividad_id
LEFT JOIN actividad_archivos aa ON a.id = aa.actividad_id
LEFT JOIN actividad_cambios ac ON a.id = ac.actividad_id
LEFT JOIN actividad_personal ap ON a.id = ap.actividad_id
LEFT JOIN usuarios u2 ON ap.usuario_id = u2.id
LEFT JOIN colaboradores col2 ON ap.colaborador_id = col2.id
LEFT JOIN LATERAL (
    SELECT STRING_AGG(s.descripcion_cambio, ' | ' ORDER BY s.fecha_cambio DESC) AS ultimos_cambios
    FROM (
        SELECT DISTINCT ON (ac2.descripcion_cambio)
               ac2.descripcion_cambio, ac2.fecha_cambio
        FROM actividad_cambios ac2
        WHERE ac2.actividad_id = a.id
        ORDER BY ac2.descripcion_cambio, ac2.fecha_cambio DESC
    ) s
) uc ON TRUE
WHERE a.eliminado_en IS NULL
GROUP BY a.id, ta.nombre, c.nombre, r.nombre, u.username, u.rol, p.nombre, 
         col.nombre, col.correo, pcol.nombre, uc.ultimos_cambios;

-- Vista: Reporte de Comunidades Alcanzadas
CREATE VIEW reporte_comunidades_alcanzadas AS
SELECT 
    c.id as comunidad_id,
    c.codigo as comunidad_codigo,
    c.nombre as comunidad,
    tc.nombre as tipo_comunidad,
    r.nombre as region,
    r.id as region_id,
    c.poblacion,
    COUNT(DISTINCT CASE WHEN a.tipo_id IN (SELECT id FROM tipos_actividad WHERE nombre = 'Capacitación') THEN a.id END) as total_capacitaciones,
    COUNT(DISTINCT CASE WHEN a.tipo_id IN (SELECT id FROM tipos_actividad WHERE nombre = 'Entrega') THEN a.id END) as total_entregas,
    COUNT(DISTINCT CASE WHEN a.tipo_id IN (SELECT id FROM tipos_actividad WHERE nombre = 'Proyecto de Ayuda') THEN a.id END) as total_proyectos,
    COUNT(DISTINCT a.id) as total_actividades,
    COUNT(DISTINCT b.id) as total_beneficiarios_comunidad,
    COUNT(DISTINCT ab.beneficiario_id) as beneficiarios_alcanzados,
    MIN(a.fecha) as primera_actividad,
    MAX(a.fecha) as ultima_actividad,
    EXTRACT(YEAR FROM MIN(a.fecha)) as anio_inicio,
    EXTRACT(YEAR FROM MAX(a.fecha)) as anio_fin,
    COUNT(DISTINCT CASE WHEN a.estado = 'completado' THEN a.id END) as actividades_completadas,
    COUNT(DISTINCT CASE WHEN a.estado = 'en_progreso' THEN a.id END) as actividades_en_progreso,
    COUNT(DISTINCT CASE WHEN a.estado = 'planificado' THEN a.id END) as actividades_planificadas,
    COUNT(DISTINCT e.id) as total_evidencias,
    CASE 
        WHEN c.poblacion > 0 THEN ROUND((COUNT(DISTINCT ab.beneficiario_id)::NUMERIC / c.poblacion * 100), 2)
        ELSE 0
    END as porcentaje_cobertura
FROM comunidades c
LEFT JOIN tipos_comunidad tc ON c.tipo_id = tc.id
LEFT JOIN regiones r ON c.region_id = r.id
LEFT JOIN actividades a ON c.id = a.comunidad_id AND a.eliminado_en IS NULL
LEFT JOIN actividad_beneficiarios ab ON a.id = ab.actividad_id
LEFT JOIN beneficiarios b ON c.id = b.comunidad_id
LEFT JOIN evidencias e ON a.id = e.actividad_id
WHERE c.activo = TRUE
GROUP BY c.id, c.codigo, c.nombre, tc.nombre, r.nombre, r.id, c.poblacion;

-- =====================================================
-- PASO 16: VISTAS - SINCRONIZACIÓN
-- =====================================================

-- Vista: Cambios Pendientes
CREATE VIEW vista_cambios_pendientes AS
SELECT 
    cs.id,
    cs.usuario_id,
    cs.dispositivo_id,
    cs.tabla,
    cs.registro_id,
    cs.operacion,
    cs.version_local,
    cs.intentos,
    cs.tiene_conflicto,
    cs.prioridad,
    cs.creado_en,
    u.username,
    EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - cs.creado_en)) as segundos_pendiente
FROM cola_sincronizacion cs
LEFT JOIN usuarios u ON cs.usuario_id = u.id
WHERE cs.sincronizado = FALSE
  AND cs.intentos < cs.max_intentos
ORDER BY cs.prioridad DESC, cs.creado_en ASC;

-- Vista: Estadísticas de Sincronización
CREATE VIEW vista_stats_sincronizacion AS
SELECT 
    usuario_id,
    dispositivo_id,
    COUNT(*) as total_pendientes,
    COUNT(*) FILTER (WHERE tiene_conflicto = TRUE) as con_conflictos,
    COUNT(*) FILTER (WHERE intentos >= 3) as con_problemas,
    MIN(creado_en) as mas_antiguo,
    MAX(creado_en) as mas_reciente,
    STRING_AGG(DISTINCT tabla, ', ') as tablas_afectadas
FROM cola_sincronizacion
WHERE sincronizado = FALSE
GROUP BY usuario_id, dispositivo_id;

-- =====================================================
-- PASO 17: VERIFICACIÓN Y MENSAJES FINALES
-- =====================================================

-- Verificar la configuración de zona horaria
SELECT 
    CURRENT_TIMESTAMP AS "Hora actual con zona",
    NOW() AS "Ahora",
    TIMEZONE('America/Guatemala', CURRENT_TIMESTAMP) AS "Convertido a Guatemala",
    CURRENT_DATE AS "Fecha actual",
    EXTRACT(TIMEZONE FROM CURRENT_TIMESTAMP)/3600 AS "Offset en horas";

-- Verificar tipos de datos de columnas timestamp
SELECT 
    table_name,
    column_name,
    data_type
FROM information_schema.columns
WHERE table_schema = 'public'
    AND data_type IN ('timestamp with time zone', 'timestamp without time zone')
    AND column_name IN ('creado_en', 'actualizado_en', 'fecha_cambio', 'eliminado_en', 'bloqueado_hasta',
                        'ultimo_login', 'ultimo_logout', 'token_expiracion', 'ultimo_acceso', 'ultimo_sync',
                        'detectado_en', 'resuelto_en', 'iniciada_en', 'expira_en', 'ultima_actividad',
                        'ultima_sincronizacion', 'fecha', 'sincronizado_en', 'ultimo_intento',
                        'procesado_en')
ORDER BY table_name, column_name;

-- Listar todas las tablas creadas
SELECT 
    table_name,
    table_type
FROM information_schema.tables
WHERE table_schema = 'public'
    AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- Listar todas las vistas creadas
SELECT 
    table_name
FROM information_schema.tables
WHERE table_schema = 'public'
    AND table_type = 'VIEW'
ORDER BY table_name;

-- Listar todas las funciones creadas
SELECT 
    routine_name,
    routine_type
FROM information_schema.routines
WHERE routine_schema = 'public'
ORDER BY routine_name;

-- =====================================================
-- MENSAJES DE CONFIRMACIÓN
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'ZONA HORARIA CONFIGURADA: America/Guatemala (UTC-6)';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'Hora actual: %', CURRENT_TIMESTAMP;
    RAISE NOTICE '';
    RAISE NOTICE '✅ Base de datos creada exitosamente';
    RAISE NOTICE '✅ Todas las columnas timestamp son timestamptz';
    RAISE NOTICE '✅ Extensiones habilitadas: uuid-ossp, pgcrypto';
    RAISE NOTICE '✅ Catálogos inicializados (tipos de comunidad, beneficiario, actividad)';
    RAISE NOTICE '✅ Tablas principales creadas (28 tablas)';
    RAISE NOTICE '✅ Tabla COLABORADORES creada e integrada';
    RAISE NOTICE '✅ Índices optimizados creados';
    RAISE NOTICE '✅ Funciones auxiliares creadas (5 funciones)';
    RAISE NOTICE '✅ Triggers configurados';
    RAISE NOTICE '✅ Vistas de reportes creadas (10 vistas)';
    RAISE NOTICE '✅ Sistema de sincronización offline configurado';
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'NUEVAS CARACTERÍSTICAS - TABLA COLABORADORES';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'Características implementadas:';
    RAISE NOTICE '  ✓ Gestión de colaboradores internos y externos';
    RAISE NOTICE '  ✓ Relación automática con usuarios (solo personal fijo)';
    RAISE NOTICE '  ✓ Vinculación con actividades y cambios';
    RAISE NOTICE '  ✓ Vistas actualizadas para reportes';
    RAISE NOTICE '  ✓ Función auxiliar para crear colaborador+usuario';
    RAISE NOTICE '  ✓ Vista de colaboradores disponibles';
    RAISE NOTICE '';
    RAISE NOTICE 'Relaciones configuradas:';
    RAISE NOTICE '  ✓ actividades.colaborador_id → colaboradores';
    RAISE NOTICE '  ✓ actividad_cambios.colaborador_id → colaboradores';
    RAISE NOTICE '  ✓ actividad_personal.colaborador_id → colaboradores';
    RAISE NOTICE '';
    RAISE NOTICE 'Uso recomendado:';
    RAISE NOTICE '  - Personal de oficina: es_personal_fijo=TRUE + usuario_id';
    RAISE NOTICE '  - Colaboradores externos: es_personal_fijo=FALSE + usuario_id=NULL';
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'SISTEMA LISTO PARA USO';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Para aplicar zona horaria permanentemente a nivel de BD:';
    RAISE NOTICE '  ALTER DATABASE tu_base_datos SET timezone TO ''America/Guatemala'';';
    RAISE NOTICE '';
    RAISE NOTICE 'Para aplicar a nivel de servidor (requiere superusuario):';
    RAISE NOTICE '  ALTER SYSTEM SET timezone = ''America/Guatemala'';';
    RAISE NOTICE '  SELECT pg_reload_conf();';
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE 'EJEMPLOS DE USO';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE '-- Crear colaborador externo:';
    RAISE NOTICE 'INSERT INTO colaboradores (nombre, puesto_id, telefono, correo, descripcion)';
    RAISE NOTICE 'VALUES (''Juan Pérez'', ''puesto_uuid'', ''12345678'', ''juan@example.com'', ''Colaborador externo'');';
    RAISE NOTICE '';
    RAISE NOTICE '-- Crear colaborador con usuario (personal fijo):';
    RAISE NOTICE 'SELECT crear_colaborador_con_usuario(';
    RAISE NOTICE '    ''María López'',';
    RAISE NOTICE '    ''puesto_uuid'',';
    RAISE NOTICE '    ''87654321'',';
    RAISE NOTICE '    ''maria@example.com'',';
    RAISE NOTICE '    ''Coordinadora de campo'',';
    RAISE NOTICE '    ''1234567890123'',';
    RAISE NOTICE '    ''mlopez'',';
    RAISE NOTICE '    ''password_hash_aqui''';
    RAISE NOTICE ');';
    RAISE NOTICE '';
    RAISE NOTICE '-- Asignar colaborador a actividad:';
    RAISE NOTICE 'UPDATE actividades SET colaborador_id = ''colaborador_uuid'' WHERE id = ''actividad_uuid'';';
    RAISE NOTICE '';
    RAISE NOTICE '-- Ver colaboradores disponibles:';
    RAISE NOTICE 'SELECT * FROM vista_colaboradores_disponibles WHERE activo = TRUE;';
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
END $$;

-- =====================================================
-- CONSULTAS ÚTILES ADICIONALES
-- =====================================================

-- Función para obtener resumen de la base de datos
CREATE OR REPLACE FUNCTION obtener_resumen_sistema()
RETURNS TABLE (
    descripcion TEXT,
    cantidad BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 'Total de Usuarios'::TEXT, COUNT(*)::BIGINT FROM usuarios
    UNION ALL
    SELECT 'Total de Colaboradores'::TEXT, COUNT(*)::BIGINT FROM colaboradores
    UNION ALL
    SELECT 'Colaboradores con Usuario'::TEXT, COUNT(*)::BIGINT FROM colaboradores WHERE usuario_id IS NOT NULL
    UNION ALL
    SELECT 'Colaboradores Externos'::TEXT, COUNT(*)::BIGINT FROM colaboradores WHERE es_personal_fijo = FALSE
    UNION ALL
    SELECT 'Total de Regiones'::TEXT, COUNT(*)::BIGINT FROM regiones
    UNION ALL
    SELECT 'Total de Comunidades'::TEXT, COUNT(*)::BIGINT FROM comunidades
    UNION ALL
    SELECT 'Total de Beneficiarios'::TEXT, COUNT(*)::BIGINT FROM beneficiarios
    UNION ALL
    SELECT 'Beneficiarios Individuales'::TEXT, COUNT(*)::BIGINT FROM beneficiarios_individuales
    UNION ALL
    SELECT 'Beneficiarios Familias'::TEXT, COUNT(*)::BIGINT FROM beneficiarios_familias
    UNION ALL
    SELECT 'Beneficiarios Instituciones'::TEXT, COUNT(*)::BIGINT FROM beneficiarios_instituciones
    UNION ALL
    SELECT 'Total de Actividades'::TEXT, COUNT(*)::BIGINT FROM actividades WHERE eliminado_en IS NULL
    UNION ALL
    SELECT 'Actividades Completadas'::TEXT, COUNT(*)::BIGINT FROM actividades WHERE estado = 'completado' AND eliminado_en IS NULL
    UNION ALL
    SELECT 'Actividades en Progreso'::TEXT, COUNT(*)::BIGINT FROM actividades WHERE estado = 'en_progreso' AND eliminado_en IS NULL
    UNION ALL
    SELECT 'Actividades Planificadas'::TEXT, COUNT(*)::BIGINT FROM actividades WHERE estado = 'planificado' AND eliminado_en IS NULL
    UNION ALL
    SELECT 'Total de Evidencias'::TEXT, COUNT(*)::BIGINT FROM evidencias
    UNION ALL
    SELECT 'Total de Cambios Registrados'::TEXT, COUNT(*)::BIGINT FROM actividad_cambios
    UNION ALL
    SELECT 'Cambios Pendientes de Sincronización'::TEXT, COUNT(*)::BIGINT FROM cola_sincronizacion WHERE sincronizado = FALSE
    UNION ALL
    SELECT 'Conflictos de Sincronización'::TEXT, COUNT(*)::BIGINT FROM conflictos_sincronizacion WHERE resuelto = FALSE;
END;
$$ LANGUAGE plpgsql;

-- Función para verificar integridad de colaboradores
CREATE OR REPLACE FUNCTION verificar_integridad_colaboradores()
RETURNS TABLE (
    tipo_problema TEXT,
    cantidad BIGINT,
    descripcion TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- Colaboradores marcados como personal fijo sin usuario
    SELECT 
        'Colaboradores sin Usuario'::TEXT,
        COUNT(*)::BIGINT,
        'Colaboradores marcados como personal fijo pero sin usuario asignado'::TEXT
    FROM colaboradores 
    WHERE es_personal_fijo = TRUE AND usuario_id IS NULL
    UNION ALL
    -- Colaboradores con usuario pero no marcados como personal fijo
    SELECT 
        'Inconsistencia Personal Fijo'::TEXT,
        COUNT(*)::BIGINT,
        'Colaboradores con usuario pero no marcados como personal fijo'::TEXT
    FROM colaboradores 
    WHERE es_personal_fijo = FALSE AND usuario_id IS NOT NULL
    UNION ALL
    -- Actividades sin colaborador ni responsable
    SELECT 
        'Actividades sin Asignación'::TEXT,
        COUNT(*)::BIGINT,
        'Actividades sin colaborador ni responsable asignado'::TEXT
    FROM actividades 
    WHERE colaborador_id IS NULL AND responsable_id IS NULL AND eliminado_en IS NULL
    UNION ALL
    -- Colaboradores inactivos con actividades activas
    SELECT 
        'Colaboradores Inactivos con Actividades'::TEXT,
        COUNT(DISTINCT c.id)::BIGINT,
        'Colaboradores inactivos que tienen actividades activas asignadas'::TEXT
    FROM colaboradores c
    INNER JOIN actividades a ON c.id = a.colaborador_id
    WHERE c.activo = FALSE 
    AND a.estado IN ('planificado', 'en_progreso')
    AND a.eliminado_en IS NULL;
END;
$$ LANGUAGE plpgsql;

-- Vista para auditoría de colaboradores
CREATE VIEW vista_auditoria_colaboradores AS
SELECT 
    c.id,
    c.nombre,
    c.es_personal_fijo,
    c.activo,
    p.nombre as puesto,
    CASE WHEN c.usuario_id IS NOT NULL THEN 'Sí' ELSE 'No' END as tiene_usuario,
    u.username,
    u.activo as usuario_activo,
    COUNT(DISTINCT a.id) FILTER (WHERE a.eliminado_en IS NULL) as total_actividades,
    COUNT(DISTINCT a.id) FILTER (WHERE a.estado IN ('planificado', 'en_progreso') AND a.eliminado_en IS NULL) as actividades_activas,
    COUNT(DISTINCT ac.id) as total_cambios_registrados,
    MAX(a.fecha) as ultima_actividad_asignada,
    MAX(ac.fecha_cambio) as ultimo_cambio_registrado,
    c.creado_en,
    c.actualizado_en,
    CASE 
        WHEN c.es_personal_fijo = TRUE AND c.usuario_id IS NULL THEN '⚠️ Falta Usuario'
        WHEN c.es_personal_fijo = FALSE AND c.usuario_id IS NOT NULL THEN '⚠️ Usuario Inesperado'
        WHEN c.activo = FALSE AND EXISTS (
            SELECT 1 FROM actividades a2 
            WHERE a2.colaborador_id = c.id 
            AND a2.estado IN ('planificado', 'en_progreso')
            AND a2.eliminado_en IS NULL
        ) THEN '⚠️ Inactivo con Actividades Activas'
        ELSE '✅ OK'
    END as estado_integridad
FROM colaboradores c
LEFT JOIN puestos p ON c.puesto_id = p.id
LEFT JOIN usuarios u ON c.usuario_id = u.id
LEFT JOIN actividades a ON c.id = a.colaborador_id
LEFT JOIN actividad_cambios ac ON c.id = ac.colaborador_id
GROUP BY c.id, c.nombre, c.es_personal_fijo, c.activo, p.nombre, c.usuario_id, u.username, u.activo, c.creado_en, c.actualizado_en;

-- Vista para estadísticas de colaboradores por puesto
CREATE VIEW vista_estadisticas_colaboradores_puesto AS
SELECT 
    p.id as puesto_id,
    p.codigo as puesto_codigo,
    p.nombre as puesto,
    COUNT(DISTINCT c.id) as total_colaboradores,
    COUNT(DISTINCT c.id) FILTER (WHERE c.es_personal_fijo = TRUE) as personal_fijo,
    COUNT(DISTINCT c.id) FILTER (WHERE c.es_personal_fijo = FALSE) as colaboradores_externos,
    COUNT(DISTINCT c.id) FILTER (WHERE c.activo = TRUE) as colaboradores_activos,
    COUNT(DISTINCT c.id) FILTER (WHERE c.usuario_id IS NOT NULL) as con_usuario,
    COUNT(DISTINCT a.id) as total_actividades_asignadas,
    COUNT(DISTINCT a.id) FILTER (WHERE a.estado = 'completado') as actividades_completadas,
    COUNT(DISTINCT ac.id) as total_cambios_registrados
FROM puestos p
LEFT JOIN colaboradores c ON p.id = c.puesto_id
LEFT JOIN actividades a ON c.id = a.colaborador_id AND a.eliminado_en IS NULL
LEFT JOIN actividad_cambios ac ON c.id = ac.colaborador_id
WHERE p.activo = TRUE
GROUP BY p.id, p.codigo, p.nombre
ORDER BY total_colaboradores DESC;

-- =====================================================
-- ÍNDICES ADICIONALES PARA PERFORMANCE
-- =====================================================

-- Índices compuestos para consultas comunes de colaboradores
CREATE INDEX idx_colaboradores_activo_personal_fijo ON colaboradores(activo, es_personal_fijo);
CREATE INDEX idx_colaboradores_puesto_activo ON colaboradores(puesto_id, activo);

-- Índices para búsquedas de texto en colaboradores
CREATE INDEX idx_colaboradores_nombre_lower ON colaboradores(LOWER(nombre));
CREATE INDEX idx_colaboradores_correo_lower ON colaboradores(LOWER(correo));

-- =====================================================
-- CONSTRAINTS ADICIONALES PARA INTEGRIDAD
-- =====================================================

-- Asegurar que al menos un colaborador esté asignado como responsable o en personal
ALTER TABLE actividades 
ADD CONSTRAINT check_tiene_responsable_o_colaborador 
CHECK (responsable_id IS NOT NULL OR colaborador_id IS NOT NULL);

-- =====================================================
-- COMENTARIOS ADICIONALES EN COLUMNAS
-- =====================================================

COMMENT ON COLUMN actividades.responsable_id IS 'Usuario responsable (legacy - mantener por compatibilidad)';
COMMENT ON COLUMN actividad_personal.usuario_id IS 'Usuario asignado al personal (legacy)';
COMMENT ON COLUMN actividad_cambios.responsable_id IS 'Usuario que registró el cambio (legacy)';

-- =====================================================
-- SCRIPT DE MIGRACIÓN DE DATOS (OPCIONAL)
-- =====================================================

-- Función para migrar usuarios existentes a colaboradores
CREATE OR REPLACE FUNCTION migrar_usuarios_a_colaboradores()
RETURNS TABLE (
    usuarios_migrados INTEGER,
    colaboradores_creados INTEGER
) AS $$
DECLARE
    v_usuarios_migrados INTEGER := 0;
    v_colaboradores_creados INTEGER := 0;
    v_usuario RECORD;
    v_colaborador_id UUID;
BEGIN
    -- Migrar usuarios con rol 'personal' a colaboradores
    FOR v_usuario IN 
        SELECT u.id, u.nombre, u.email, u.telefono, u.puesto_id
        FROM usuarios u
        WHERE u.rol = 'personal' 
        AND u.activo = TRUE
        AND NOT EXISTS (
            SELECT 1 FROM colaboradores c WHERE c.usuario_id = u.id
        )
    LOOP
        -- Crear colaborador para este usuario
        INSERT INTO colaboradores (
            nombre,
            puesto_id,
            telefono,
            correo,
            es_personal_fijo,
            usuario_id,
            activo,
            descripcion
        ) VALUES (
            COALESCE(v_usuario.nombre, 'Sin nombre'),
            v_usuario.puesto_id,
            v_usuario.telefono,
            v_usuario.email,
            TRUE,
            v_usuario.id,
            TRUE,
            'Migrado automáticamente desde usuarios'
        ) RETURNING id INTO v_colaborador_id;
        
        v_usuarios_migrados := v_usuarios_migrados + 1;
        v_colaboradores_creados := v_colaboradores_creados + 1;
        
        RAISE NOTICE 'Usuario % migrado a colaborador %', v_usuario.id, v_colaborador_id;
    END LOOP;
    
    RETURN QUERY SELECT v_usuarios_migrados, v_colaboradores_creados;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- MENSAJE FINAL DE CONFIRMACIÓN
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '🎉 INSTALACIÓN COMPLETADA EXITOSAMENTE';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '';
    RAISE NOTICE 'Resumen del sistema:';
    RAISE NOTICE '  📊 28 Tablas principales';
    RAISE NOTICE '  👁️  10 Vistas de consulta y reportes';
    RAISE NOTICE '  ⚙️  5 Funciones auxiliares';
    RAISE NOTICE '  🔧 3 Funciones adicionales de utilidad';
    RAISE NOTICE '  🔗 Múltiples triggers automáticos';
    RAISE NOTICE '  📍 Índices optimizados para performance';
    RAISE NOTICE '';
    RAISE NOTICE 'Funciones útiles disponibles:';
    RAISE NOTICE '  • obtener_resumen_sistema()';
    RAISE NOTICE '  • verificar_integridad_colaboradores()';
    RAISE NOTICE '  • migrar_usuarios_a_colaboradores()';
    RAISE NOTICE '  • crear_colaborador_con_usuario(...)';
    RAISE NOTICE '';
    RAISE NOTICE 'Vistas útiles disponibles:';
    RAISE NOTICE '  • vista_colaboradores_completos';
    RAISE NOTICE '  • vista_colaboradores_disponibles';
    RAISE NOTICE '  • vista_auditoria_colaboradores';
    RAISE NOTICE '  • vista_estadisticas_colaboradores_puesto';
    RAISE NOTICE '';
    RAISE NOTICE 'Próximos pasos recomendados:';
    RAISE NOTICE '  1. Verificar integridad: SELECT * FROM verificar_integridad_colaboradores();';
    RAISE NOTICE '  2. Ver resumen: SELECT * FROM obtener_resumen_sistema();';
    RAISE NOTICE '  3. Migrar usuarios existentes: SELECT * FROM migrar_usuarios_a_colaboradores();';
    RAISE NOTICE '  4. Crear puestos necesarios en la tabla "puestos"';
    RAISE NOTICE '  5. Configurar zona horaria permanente en la BD';
    RAISE NOTICE '';
    RAISE NOTICE '=====================================================';
    RAISE NOTICE '✅ Sistema listo para comenzar a trabajar';
    RAISE NOTICE '=====================================================';
END $$;




-- =====================================================
-- TABLA: RECORDATORIOS (para calendario/alertas)
-- =====================================================
CREATE TABLE recordatorios (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

    -- Relación opcional al evento (actividad)
    actividad_id UUID REFERENCES actividades(id) ON DELETE SET NULL,

    -- Autor del recordatorio (usuario del sistema)
    created_by UUID REFERENCES usuarios(id) ON DELETE SET NULL,

    -- Contenido
    titulo VARCHAR(200),
    descripcion TEXT,

    -- Momento del recordatorio (zona horaria a nivel de valor)
    due_at TIMESTAMPTZ NOT NULL,

    -- Flags de notificación
    enviar_notificacion BOOLEAN DEFAULT TRUE,
    enviado BOOLEAN DEFAULT FALSE,

    -- Auditoría
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    actualizado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Índices útiles para consultas y jobs de notificación
CREATE INDEX idx_recordatorios_due_at          ON recordatorios(due_at);
CREATE INDEX idx_recordatorios_actividad       ON recordatorios(actividad_id);
CREATE INDEX idx_recordatorios_created_by      ON recordatorios(created_by);
CREATE INDEX idx_recordatorios_enviar_enviado  ON recordatorios(enviar_notificacion, enviado);

COMMENT ON TABLE recordatorios IS 'Recordatorios del calendario. due_at = fecha/hora de disparo.';

-- Trigger de timestamp (reutiliza la función existente)
CREATE TRIGGER trg_recordatorios_timestamp
BEFORE UPDATE ON recordatorios
FOR EACH ROW
EXECUTE FUNCTION actualizar_timestamp();

-- =====================================================
-- TABLA INTERMEDIA: INVOLUCRADOS EN RECORDATORIOS (M2M)
-- =====================================================
CREATE TABLE recordatorio_colaboradores (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    recordatorio_id UUID NOT NULL REFERENCES recordatorios(id) ON DELETE CASCADE,
    colaborador_id UUID NOT NULL REFERENCES colaboradores(id) ON DELETE CASCADE,
    creado_en TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(recordatorio_id, colaborador_id)
);

CREATE INDEX idx_recordatorio_colab_recordatorio ON recordatorio_colaboradores(recordatorio_id);
CREATE INDEX idx_recordatorio_colab_colaborador  ON recordatorio_colaboradores(colaborador_id);

COMMENT ON TABLE recordatorio_colaboradores IS 'Colaboradores involucrados en un recordatorio.';

